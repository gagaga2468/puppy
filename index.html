<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>极简贪吃蛇</title>
    <style>
      :root {
        color-scheme: light;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f6f6f6;
        color: #1f1f1f;
      }
      .wrap {
        width: min(92vw, 420px);
        padding: 24px;
        border-radius: 20px;
        background: #ffffff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08);
        display: flex;
        flex-direction: column;
        gap: 16px;
        align-items: center;
      }
      h1 {
        font-size: 20px;
        margin: 0;
        font-weight: 600;
      }
      canvas {
        width: 100%;
        aspect-ratio: 1;
        background: #fafafa;
        border-radius: 16px;
        border: 1px solid #ececec;
      }
      .speed {
        width: 100%;
        display: grid;
        gap: 6px;
        font-size: 13px;
        color: #6b6b6b;
      }
      .speed-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .speed-range {
        width: 100%;
        accent-color: #1f1f1f;
      }
      .speed-labels {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #9b9b9b;
      }
      .controls {
        display: flex;
        gap: 12px;
      }
      button {
        border: none;
        padding: 10px 20px;
        border-radius: 999px;
        background: #1f1f1f;
        color: #fff;
        font-size: 14px;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      button:active {
        transform: scale(0.96);
      }
      button.secondary {
        background: #e4e4e4;
        color: #1f1f1f;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .status {
        font-size: 13px;
        color: #6b6b6b;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>极简贪吃蛇</h1>
      <canvas id="game" width="360" height="360"></canvas>
      <div class="controls">
        <button id="start">开始</button>
        <button id="end" class="secondary">结束</button>
      </div>
      <div class="speed">
        <div class="speed-header">
          <span>速度</span>
          <span id="speedValue">快</span>
        </div>
        <input
          id="speed"
          class="speed-range"
          type="range"
          min="0"
          max="2"
          step="1"
          value="0"
          aria-label="速度调节"
        />
        <div class="speed-labels">
          <span>快</span>
          <span>中</span>
          <span>慢</span>
        </div>
      </div>
      <div class="status" id="status">按开始进入游戏</div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const statusText = document.getElementById("status");
      const startBtn = document.getElementById("start");
      const endBtn = document.getElementById("end");
      const speedSelect = document.getElementById("speed");
      const speedValue = document.getElementById("speedValue");

      const gridSize = 18;
      const tileCount = canvas.width / gridSize;

      let snake = [];
      let direction = { x: 1, y: 0 };
      let pendingDirection = { x: 1, y: 0 };
      let foods = [];
      let timer = null;
      let running = false;
      let score = 0;
      let currentSpeed = "fast";

      const setButtons = (isRunning) => {
        startBtn.disabled = isRunning;
        endBtn.disabled = !isRunning;
      };

      const speedOptions = ["fast", "medium", "slow"];
      const speedLabels = {
        fast: "快",
        medium: "中",
        slow: "慢",
      };
      const speedMap = {
        fast: 240,
        medium: 320,
        slow: 440,
      };

      const restartTimer = () => {
        if (!running) {
          return;
        }
        clearInterval(timer);
        timer = setInterval(step, speedMap[currentSpeed]);
      };

      const resetGame = () => {
        snake = [
          { x: 6, y: 9 },
          { x: 5, y: 9 },
          { x: 4, y: 9 },
        ];
        direction = { x: 1, y: 0 };
        pendingDirection = { x: 1, y: 0 };
        foods = [];
        fillFoods();
        draw();
      };

      const placeFood = () => {
        let newFood;
        do {
          newFood = {
            x: Math.floor(Math.random() * tileCount),
            y: Math.floor(Math.random() * tileCount),
          };
        } while (
          snake.some((segment) => segment.x === newFood.x && segment.y === newFood.y) ||
          foods.some((food) => food.x === newFood.x && food.y === newFood.y)
        );
        foods.push(newFood);
      };

      const fillFoods = () => {
        while (foods.length < 5) {
          placeFood();
        }
      };

      const draw = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#1b8f3a";
        snake.forEach((segment, index) => {
          ctx.globalAlpha = 1 - index * 0.04;
          ctx.fillRect(
            segment.x * gridSize + 2,
            segment.y * gridSize + 2,
            gridSize - 4,
            gridSize - 4
          );
        });
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#ff6a00";
        foods.forEach((food) => {
          ctx.beginPath();
          ctx.arc(
            food.x * gridSize + gridSize / 2,
            food.y * gridSize + gridSize / 2,
            gridSize / 3,
            0,
            Math.PI * 2
          );
          ctx.fill();
        });
      };

      const step = () => {
        direction = { ...pendingDirection };
        const head = snake[0];
        const next = { x: head.x + direction.x, y: head.y + direction.y };

        if (
          next.x < 0 ||
          next.y < 0 ||
          next.x >= tileCount ||
          next.y >= tileCount ||
          snake.some((segment) => segment.x === next.x && segment.y === next.y)
        ) {
          stopGame("游戏结束，点击开始重来");
          return;
        }

        snake.unshift(next);
        const foodIndex = foods.findIndex((food) => food.x === next.x && food.y === next.y);
        if (foodIndex >= 0) {
          score += 1;
          foods.splice(foodIndex, 1);
          fillFoods();
          statusText.textContent = `游戏进行中，得分：${score}（方向键或鼠标点击控制）`;
        } else {
          snake.pop();
        }
        draw();
      };

      const startGame = () => {
        if (running) {
          return;
        }
        running = true;
        score = 0;
        statusText.textContent = "游戏进行中，得分：0（方向键或鼠标点击控制）";
        resetGame();
        setButtons(true);
        speedValue.textContent = speedLabels[currentSpeed];
        restartTimer();
      };

      const stopGame = (message = "游戏已结束") => {
        running = false;
        clearInterval(timer);
        timer = null;
        statusText.textContent = message;
        setButtons(false);
      };

      const setDirection = (x, y) => {
        if (!running) {
          return;
        }
        if (direction.x + x === 0 && direction.y + y === 0) {
          return;
        }
        pendingDirection = { x, y };
      };

      document.addEventListener("keydown", (event) => {
        switch (event.key) {
          case "ArrowUp":
            setDirection(0, -1);
            break;
          case "ArrowDown":
            setDirection(0, 1);
            break;
          case "ArrowLeft":
            setDirection(-1, 0);
            break;
          case "ArrowRight":
            setDirection(1, 0);
            break;
          default:
            break;
        }
      });

      canvas.addEventListener("click", (event) => {
        if (!running) {
          return;
        }
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        const head = snake[0];
        const headX = head.x * gridSize + gridSize / 2;
        const headY = head.y * gridSize + gridSize / 2;
        const deltaX = clickX - headX;
        const deltaY = clickY - headY;

        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          setDirection(deltaX > 0 ? 1 : -1, 0);
        } else if (deltaY !== 0) {
          setDirection(0, deltaY > 0 ? 1 : -1);
        }
      });

      startBtn.addEventListener("click", startGame);
      endBtn.addEventListener("click", () => stopGame("游戏已结束"));
      speedSelect.addEventListener("input", (event) => {
        const index = Number(event.target.value);
        currentSpeed = speedOptions[index];
        speedValue.textContent = speedLabels[currentSpeed];
        restartTimer();
      });

      resetGame();
      setButtons(false);
      speedValue.textContent = speedLabels[currentSpeed];
    </script>
  </body>
</html>
